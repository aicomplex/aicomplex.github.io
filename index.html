<!DOCTYPE html>
<html lang="en">
<head>
<title>AICS Home</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="https://fonts.googleapis.com/css2?family=Sunflower:wght@300;500;700&display=swap" rel="stylesheet">
 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
* {
  box-sizing: border-box;
}

body {
  font-family: Arial, Helvetica, sans-serif;
  margin: 0;
  background-color: #000; /* Changed from #f9f9f9 to black */
  color: #fff; /* Changed from #333 to white for better contrast */
}

.header {
  padding: 20px;
  background: #000; 
  color: white;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-family: 'Sunflower', sans-serif;
}

.header .left-content {
  display: flex;
  align-items: center;
}

.header h1 {
  margin-left: 20px;
  margin-bottom: 0;
  font-size: 36px; /* Increased from 36px to 48px */
  font-family: 'Sunflower', sans-serif;
  font-weight: 700; /* Added bold weight */
  letter-spacing: 1px; /* Added letter spacing for better readability */
}

.logo {
  height: 100%;
  object-fit: contain;
}

#logo1 {
  margin-left: -20px;
  height: 115px; 
  width: auto; 
}
#logo2 {
  height: 140px; 
  width: auto; 
}

.navbar {
  overflow: hidden;
  background-color: #333;
  font-family: 'Sunflower', sans-serif;
}

.navbar a {
  float: left;
  display: block;
  color: white;
  text-align: center;
  padding: 20px 20px;
  text-decoration: none;
  font-size: 18px;
  font-family: 'Sunflower', sans-serif;
}

.navbar a.right {
  float: right;
}

.navbar a:hover {
  background-color: #ddd;
  color: black;
}

.row {
  display: -ms-flexbox;
  display: flex;
  -ms-flex-wrap: wrap;
  flex-wrap: wrap;
}

.side {
  -ms-flex: 30%;
  flex: 30%;
  background-color: #f1f1f1;
  padding: 20px;
}
.tooltip {
  /* position: fixed; - removed */
  display: none;
  background-color: white;
  border-radius: 8px;
  padding: 20px;
  max-width: 600px; /* Increased width for fixed position */
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  z-index: 1000;
  font-family: 'Sunflower', sans-serif;
  transition: opacity 0.3s ease;
  border-left: 4px solid #3c4c4e;
  /* pointer-events: none; - removed to allow scrolling if needed */
}

.tooltip-title {
  font-size: 22px; /* Increased from 20px */
  font-weight: 700;
  margin-bottom: 8px;
  color: #2a3638;
  border-bottom: 1px solid #eee;
  padding-bottom: 5px;
}

.tooltip-content {
  font-size: 18px; /* Increased from 16px */
  line-height: 1.4;
  color: #333;
}
.main {
  -ms-flex: 70%;
  flex: 70%;
  background-color: #000; /* Changed from white to black */
  padding: 40px;
  max-width: 1200px;
  margin: 0 auto;
}

.main p {
  font-size: 22px;
  color: #fff; /* Changed from #333 to white */
  font-family: 'Sunflower', sans-serif;
  line-height: 1.6;
  max-width: 900px;
  margin: 0 auto 30px;
  text-align: justify;
  padding: 25px;
  background-color: #111; /* Changed from #f9f9f9 to dark gray */
  border-left: 4px solid #fed802;
  border-radius: 0 8px 8px 0;
  box-shadow: 0 2px 5px rgba(255,255,255,0.05), 0 0 0 1px rgba(254, 216, 2, 0.1);
}

.main p strong {
  color: #2a3638;
}
.main img {
  max-width: 100%; 
  height: auto; 
  display: block; 
  margin: 0 auto; 
}

.news-line {
  background-color: black; /* Changed from transparent to black */
  color: #333; 
  padding: 10px 15px; 
  display: flex; 
  align-items: center; 
  gap: 15px; 
  justify-content: center;
}

.news-line i.fa-bell {
  color: gold;
  font-size: 20px; 
  text-shadow: 0px 0px 1px #ffd700, 
               0px 0px 3px #ffd700, 
               0px 0px 1px #ffbf00, 
               0px 0px 5px #ffbf00; 
}

.substack-link {
  background: linear-gradient(to right, #f8f8f8, #ffffff);
  padding: 8px 15px;
  border-radius: 20px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: all 0.3s ease;
}

.substack-link:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.substack-link a {
  color: #333;
  text-decoration: none !important;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 18px;
  font-family: 'Sunflower', sans-serif;
}

.substack-link a i {
  color: #fed802;
  font-size: 18px;
}

.substack-link a:hover {
  color: #007bff !important;
}

.learn-more-btn {
  display: inline-block; 
  margin: 20px auto;
  padding: 10px 20px;
  background-color: #333333c7;
  color: white;
  border: 2px solid #333333c7;
  border-radius: 5px;
  cursor: pointer;
  text-align: center;
  text-decoration: none;
  font-size: 20px;
  font-family: 'Sunflower', sans-serif;
  transition: all 0.3s ease;
}

.learn-more-btn:hover {
  background-color: #fed802;
  color: #333;
  transform: translateY(-3px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.partner-badge {
  background-color: #000; 
  color: white;
  padding: 50px; 
  text-align: left;
  font-size: 28px; 
  font-weight: bold;
  font-family: 'Sunflower', sans-serif;
}

.email-button {
  background: transparent; 
  display: inline-block; 
  color: white; 
  padding: 10px 15px; 
  margin-top: 10px; 
  text-decoration: none; 
  border-radius: 5px; 
  font-size: 30px; 
  cursor: pointer; 
}

@media screen and (max-width: 700px) {
  .row {
    flex-direction: column;
  }
  .header h1 {
    font-size: 32px; /* Adjusted responsive size */
  }
}

@media screen and (max-width: 400px) {
  .navbar a {
    float: none;
    width: 100%;
  }
  .navbar a {
    font-size: 16px;
    padding: 15px;
  }
}
</style>
</head>
<body>

<div class="header">
  <div class="left-content">
    <img src="AICS-logo.png" alt="AICS logo" class="logo" id="logo1">
    <h1>Artificial Intelligence and Complex Systems (AICS)</h1>
  </div>
  <a href="https://www.isi.edu/" target="_blank" style="display: flex; align-items: center; padding: 0; margin-right: -10px;">
    <img src="ISI-logo.png" alt="ISI logo" class="logo" id="logo2" style="height: 160px; width: auto;">
  </a>
</div>

<div class="navbar">
    <a href="index.html">Home</a>
    <!--  <a href="projects.html">Projects</a> -->
  <a href="people.html">People</a>
  <a href="projects.html">Projects</a>
  <a href="pubs.html">Publications</a>
  <a href="press.html">Press</a>
  <a href="talks.html"> Academic Outreach</a>
  <a href="gallery.html">Gallery</a>
</div>

<!-- In the body section, adding the ping pong game as main content -->
<!-- Removing the news-line section -->

<!-- Removing padding and margins to eliminate white borders -->
<div style="display: flex; justify-content: center; align-items: center; background-color: black; padding: 0; margin: 0; height: calc(100vh - 220px); width: 100%; overflow: hidden;">
  <canvas width="750" height="585" id="game"></canvas>
</div>

<!-- Adding footer container -->
<footer style="background-color: #111; color: white; padding: 10px 0; text-align: center; font-family: 'Sunflower', sans-serif; border-top: 1px solid #333;">
  <div style="max-width: 1200px; margin: 0 auto; display: flex; flex-direction: column; align-items: center; padding: 0 20px;">
    <!-- Button container -->
    <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; margin-bottom: 15px;">
      <!-- Contact Us button -->
      <a href="mailto:kejriwal@isi.edu" class="footer-button" style="background-color: #222; color: white; padding: 12px 24px; border-radius: 30px; text-decoration: none; display: flex; align-items: center; transition: all 0.3s ease; border: 1px solid #444;">
        <i class="fa fa-envelope" style="color: #fed802; margin-right: 10px; font-size: 18px;"></i>
        <span style="font-size: 16px; font-weight: 500;">Contact Us</span>
      </a>
      
      <!-- Substack button -->
      <a href="https://aiscientist.substack.com/" target="_blank" class="footer-button" style="background-color: #222; color: white; padding: 12px 24px; border-radius: 30px; text-decoration: none; display: flex; align-items: center; transition: all 0.3s ease; border: 1px solid #444;">
        <i class="fa fa-newspaper-o" style="color: #fed802; margin-right: 10px; font-size: 18px;"></i>
        <span style="font-size: 16px; font-weight: 500;">Substack</span>
      </a>
      
      <!-- USC Viterbi button -->
      <a href="https://viterbischool.usc.edu/" target="_blank" class="footer-button" style="background-color: #222; color: white; padding: 12px 24px; border-radius: 30px; text-decoration: none; display: flex; align-items: center; transition: all 0.3s ease; border: 1px solid #444;">
        <i class="fa fa-university" style="color: #fed802; margin-right: 10px; font-size: 18px;"></i>
        <span style="font-size: 16px; font-weight: 500;">USC Viterbi</span>
      </a>
    </div>
    
    <!-- Copyright info only -->
    <div style="margin: 5px 0 0;">
      <p style="margin: 0; font-size: 14px;">Â© 2025 Artificial Intelligence and Complex Systems</p>
    </div>
  </div>
  
  <!-- Add hover effects for buttons -->
  <style>
    .footer-button:hover {
      background-color: #333 !important;
      transform: translateY(-3px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      border-color: #fed802 !important;
    }
  </style>
</footer>

<!-- Replace the Venn diagram script with the ping pong game script -->
<script>
const canvas = document.getElementById('game');
const context = canvas.getContext('2d');

// Make canvas responsive
function resizeCanvas() {
  const container = canvas.parentElement;
  const containerWidth = container.clientWidth;
  const containerHeight = container.clientHeight;
  
  // Set canvas to fill the container while maintaining aspect ratio
  const aspectRatio = 1.5;
  
  // Calculate dimensions to fit the container
  let newWidth, newHeight;
  
  if (containerWidth / containerHeight > aspectRatio) {
    // Container is wider than needed for aspect ratio
    newHeight = containerHeight;
    newWidth = newHeight * aspectRatio;
  } else {
    // Container is taller than needed for aspect ratio
    newWidth = containerWidth;
    newHeight = newWidth / aspectRatio;
  }
  
  // Set canvas size
  canvas.width = newWidth;
  canvas.height = newHeight;
  
  // Update game parameters after resize
  updateGameParameters();
}

// Call resize on page load and window resize
window.addEventListener('load', resizeCanvas);
window.addEventListener('resize', resizeCanvas);

// Game parameters that will be updated when canvas resizes
let grid, paddleHeight, maxPaddleY, paddleSpeed, ballSpeed;
// Add score tracking
let leftScore = 0;
let rightScore = 0;
// Add particle system
let particles = [];

function updateGameParameters() {
  // Scale game elements based on canvas size
  grid = Math.max(15, Math.floor(canvas.width / 40));
  paddleHeight = grid * 6;
  maxPaddleY = canvas.height - grid - paddleHeight;
  paddleSpeed = Math.max(5, Math.floor(canvas.width / 120));
  ballSpeed = Math.max(4, Math.floor(canvas.width / 150));
  
  // Update paddle and ball positions/sizes
  leftPaddle.width = grid;
  leftPaddle.height = paddleHeight;
  leftPaddle.x = grid * 2;
  leftPaddle.y = canvas.height / 2 - paddleHeight / 2;
  
  rightPaddle.width = grid;
  rightPaddle.height = paddleHeight;
  rightPaddle.x = canvas.width - grid * 3;
  rightPaddle.y = canvas.height / 2 - paddleHeight / 2;
  
  ball.width = grid;
  ball.height = grid;
  ball.x = canvas.width / 2;
  ball.y = canvas.height / 2;
  ball.dx = ball.dx > 0 ? ballSpeed : -ballSpeed;
  ball.dy = ball.dy > 0 ? ballSpeed : -ballSpeed;
}

// Initial game parameters (will be updated by resizeCanvas)
grid = 25;
paddleHeight = grid * 6;
maxPaddleY = canvas.height - grid - paddleHeight;
paddleSpeed = 8;
ballSpeed = 6;

const leftPaddle = {
  // start in the middle of the game on the left side
  x: grid * 2,
  y: canvas.height / 2 - paddleHeight / 2,
  width: grid,
  height: paddleHeight,

  // paddle velocity
  dy: 0
};
const rightPaddle = {
  // start in the middle of the game on the right side
  x: canvas.width - grid * 3,
  y: canvas.height / 2 - paddleHeight / 2,
  width: grid,
  height: paddleHeight,

  // paddle velocity
  dy: 0
};
const ball = {
  // start in the middle of the game
  x: canvas.width / 2,
  y: canvas.height / 2,
  width: grid,
  height: grid,

  // keep track of when need to reset the ball position
  resetting: false,

  // ball velocity (start going to the top-right corner)
  dx: ballSpeed,
  dy: -ballSpeed
};

// Add particle class for visual effects
class Particle {
  constructor(x, y, dx, dy, size, life) {
    this.x = x;
    this.y = y;
    this.dx = dx;
    this.dy = dy;
    this.size = size;
    this.life = life;
    this.maxLife = life;
  }
  
  update() {
    this.x += this.dx;
    this.y += this.dy;
    this.life--;
    return this.life > 0;
  }
  
  draw() {
    const alpha = this.life / this.maxLife;
    context.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    context.fillRect(this.x, this.y, this.size, this.size);
  }
}

// Add screen shake effect
let screenShake = 0;
function applyScreenShake() {
  if (screenShake > 0) {
    const shakeX = (Math.random() - 0.5) * screenShake;
    const shakeY = (Math.random() - 0.5) * screenShake;
    context.translate(shakeX, shakeY);
    screenShake *= 0.9;
    if (screenShake < 0.5) screenShake = 0;
  }
}

// Add slow motion effect when ball is about to score
let slowMotion = 0;
function updateSlowMotion() {
  if (slowMotion > 0) {
    slowMotion--;
  }
}

// Function to create particles when ball hits paddle
function createHitParticles(x, y, direction) {
  const particleCount = 15;
  for (let i = 0; i < particleCount; i++) {
    const angle = Math.random() * Math.PI - Math.PI/2;
    const speed = Math.random() * 3 + 2;
    const dx = Math.cos(angle) * speed * direction;
    const dy = Math.sin(angle) * speed;
    const size = Math.random() * 3 + 1;
    const life = Math.random() * 20 + 10;
    particles.push(new Particle(x, y, dx, dy, size, life));
  }
}

// check for collision between two objects using axis-aligned bounding box (AABB)
// @see https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection
function collides(obj1, obj2) {
  return obj1.x < obj2.x + obj2.width &&
         obj1.x + obj1.width > obj2.x &&
         obj1.y < obj2.y + obj2.height &&
         obj1.y + obj1.height > obj2.y;
}

// AI for paddles to follow the ball
function updatePaddleAI() {
  // Left paddle AI
  const leftPaddleCenter = leftPaddle.y + paddleHeight/2;
  if (ball.dx < 0) { // Only move if ball is coming towards this paddle
    if (leftPaddleCenter < ball.y - paddleHeight/4) {
      leftPaddle.dy = paddleSpeed;
    } else if (leftPaddleCenter > ball.y + paddleHeight/4) {
      leftPaddle.dy = -paddleSpeed;
    } else {
      leftPaddle.dy = 0;
    }
  } else {
    // Return to center when ball is moving away
    if (leftPaddleCenter < canvas.height/2 - paddleHeight/4) {
      leftPaddle.dy = paddleSpeed/2;
    } else if (leftPaddleCenter > canvas.height/2 + paddleHeight/4) {
      leftPaddle.dy = -paddleSpeed/2;
    } else {
      leftPaddle.dy = 0;
    }
  }
  
  // Right paddle AI
  const rightPaddleCenter = rightPaddle.y + paddleHeight/2;
  if (ball.dx > 0) { // Only move if ball is coming towards this paddle
    if (rightPaddleCenter < ball.y - paddleHeight/4) {
      rightPaddle.dy = paddleSpeed;
    } else if (rightPaddleCenter > ball.y + paddleHeight/4) {
      rightPaddle.dy = -paddleSpeed;
    } else {
      rightPaddle.dy = 0;
    }
  } else {
    // Return to center when ball is moving away
    if (rightPaddleCenter < canvas.height/2 - paddleHeight/4) {
      rightPaddle.dy = paddleSpeed/2;
    } else if (rightPaddleCenter > canvas.height/2 + paddleHeight/4) {
      rightPaddle.dy = -paddleSpeed/2;
    } else {
      rightPaddle.dy = 0;
    }
  }
}

// Draw a more detailed, round ball with highlights and shadow
function drawBall() {
  // Create a pixelated round ball using even smaller squares for more granularity
  const pixelSize = 2; // Even smaller pixel size for smoother appearance
  const ballRadius = grid / 1.4; // Slightly larger radius
  const centerX = ball.x + ball.width/2;
  const centerY = ball.y + ball.height/2;
  
  // Draw ball shadow first (gray pixels offset from the ball)
  context.fillStyle = '#777777'; // Lighter gray for shadow
  for (let y = -ballRadius; y <= ballRadius; y += pixelSize) {
    for (let x = -ballRadius; x <= ballRadius; x += pixelSize) {
      // If this pixel is within the circle radius
      if (x*x + y*y <= ballRadius*ballRadius) {
        context.fillRect(
          Math.floor(centerX + x + 4), 
          Math.floor(centerY + y + 4), 
          pixelSize, 
          pixelSize
        );
      }
    }
  }
  
  // Draw the white ball
  context.fillStyle = 'white';
  for (let y = -ballRadius; y <= ballRadius; y += pixelSize) {
    for (let x = -ballRadius; x <= ballRadius; x += pixelSize) {
      // If this pixel is within the circle radius
      if (x*x + y*y <= ballRadius*ballRadius) {
        context.fillRect(
          Math.floor(centerX + x), 
          Math.floor(centerY + y), 
          pixelSize, 
          pixelSize
        );
      }
    }
  }
  
  // Add black pixel highlights for depth and dimension
  context.fillStyle = 'black';
  
  // Top-left shadow (inner part of the ball)
  for (let y = -ballRadius/2; y < 0; y += pixelSize) {
    for (let x = -ballRadius/2; x < 0; x += pixelSize) {
      // Only add highlights in certain areas for a 3D effect
      if (x*x + y*y <= (ballRadius/2.5)*(ballRadius/2.5) && 
          x*x + y*y >= (ballRadius/4)*(ballRadius/4)) {
        context.fillRect(
          Math.floor(centerX + x), 
          Math.floor(centerY + y), 
          pixelSize, 
          pixelSize
        );
      }
    }
  }
  
  // Bottom-right highlight (reflection)
  context.fillStyle = 'white';
  for (let y = ballRadius/6; y < ballRadius/2; y += pixelSize) {
    for (let x = ballRadius/6; x < ballRadius/2; x += pixelSize) {
      // Small bright spot for reflection
      if (x*x + y*y <= (ballRadius/4)*(ballRadius/4)) {
        context.fillRect(
          Math.floor(centerX + x), 
          Math.floor(centerY + y), 
          pixelSize, 
          pixelSize
        );
      }
    }
  }
}

// Function to draw pixelated text with 3D effect
function drawPixelText(text, x, y, size = 10) {
  const pixelSize = 10; // Large text size
  
  // First draw gray shadow for 3D effect - using lighter gray
  context.fillStyle = '#777777'; // Lighter gray for shadows
  let shadowX = x + 3;
  let shadowY = y + 3;
  
  // Pixel patterns for letters
  const letters = {
    'A': [
      [0,1,1,0],
      [1,0,0,1],
      [1,1,1,1],
      [1,0,0,1],
      [1,0,0,1]
    ],
    'I': [
      [1,1,1],
      [0,1,0],
      [0,1,0],
      [0,1,0],
      [1,1,1]
    ],
    'C': [
      [0,1,1,1],
      [1,0,0,0],
      [1,0,0,0],
      [1,0,0,0],
      [0,1,1,1]
    ],
    'S': [
      [0,1,1,1],
      [1,0,0,0],
      [0,1,1,0],
      [0,0,0,1],
      [1,1,1,0]
    ]
  };
  
  // Draw shadow first
  for (let i = 0; i < text.length; i++) {
    const letter = text[i];
    if (letters[letter]) {
      const pattern = letters[letter];
      
      // Draw shadow pixel by pixel
      for (let row = 0; row < pattern.length; row++) {
        for (let col = 0; col < pattern[row].length; col++) {
          if (pattern[row][col] === 1) {
            context.fillRect(
              shadowX + col * pixelSize,
              shadowY + row * pixelSize,
              pixelSize,
              pixelSize
            );
          }
        }
      }
      
      // Move to the next letter position
      shadowX += (pattern[0].length + 2) * pixelSize;
    }
  }
  
  // Now draw the white text on top
  context.fillStyle = 'white';
  let currentX = x;
  
  for (let i = 0; i < text.length; i++) {
    const letter = text[i];
    if (letters[letter]) {
      const pattern = letters[letter];
      
      // Draw the letter pixel by pixel
      for (let row = 0; row < pattern.length; row++) {
        for (let col = 0; col < pattern[row].length; col++) {
          if (pattern[row][col] === 1) {
            context.fillRect(
              currentX + col * pixelSize,
              y + row * pixelSize,
              pixelSize,
              pixelSize
            );
          }
        }
      }
      
      // Move to the next letter position
      currentX += (pattern[0].length + 2) * pixelSize;
    }
  }
}

// Draw the court with more detailed pixel art and 3D effects
function drawCourt() {
  // Now draw both walls in black without shadows
  context.fillStyle = 'black';
  
  // Pixelated top wall
  for (let x = 0; x < canvas.width; x += 3) {
    context.fillRect(x, 0, 3, grid);
  }
  
  // Pixelated bottom wall also in black
  for (let x = 0; x < canvas.width; x += 3) {
    context.fillRect(x, canvas.height - grid, 3, grid);
  }
  
  // Center line with thicker pixelated dashes
  const dashHeight = grid / 2;
  const gapHeight = grid;
  
  // Draw white center line with thicker dashes
  context.fillStyle = 'white';
  for (let y = grid * 1.5; y < canvas.height - grid * 1.5; y += dashHeight + gapHeight) {
    // Each dash is made of small pixel blocks, but thicker
    for (let py = 0; py < dashHeight; py += 3) {
      context.fillRect(canvas.width / 2 - 2, y + py, 4, 3); // Increased width from 2 to 4
    }
  }
  
  // Draw pixelated "AI" and "CS" text with 3D effect
  drawPixelText("AI", canvas.width / 4 - 60, 70);
  drawPixelText("CS", canvas.width * 3/4 - 60, 70);
}

// Draw a more pixelated paddle with 3D effect
function drawPaddle(paddle, isLeft) {
  // Draw gray shadow for 3D effect - using lighter gray
  context.fillStyle = '#777777'; // Lighter gray for shadows
  
  // Draw paddle shadow
  for (let y = 0; y < paddle.height; y += 3) {
    for (let x = 0; x < paddle.width; x += 3) {
      context.fillRect(paddle.x + x + 3, paddle.y + y + 3, 3, 3);
    }
  }
  
  // Draw the white paddle on top
  context.fillStyle = 'white';
  
  // Draw paddle as a grid of pixels
  for (let y = 0; y < paddle.height; y += 3) {
    for (let x = 0; x < paddle.width; x += 3) {
      context.fillRect(paddle.x + x, paddle.y + y, 3, 3);
    }
  }
}

// game loop
function loop() {
  requestAnimationFrame(loop);
  
  // Clear with screen shake effect
  context.fillStyle = 'black';
  context.save();
  context.setTransform(1, 0, 0, 1, 0, 0);
  context.fillRect(0, 0, canvas.width, canvas.height);
  context.restore();
  
  context.save();
  applyScreenShake();

  // Update paddle AI
  updatePaddleAI();

  // Update slow motion
  updateSlowMotion();
  
  // Determine game speed based on slow motion
  const gameSpeed = slowMotion > 0 ? 0.3 : 1;

  // move paddles by their velocity
  leftPaddle.y += leftPaddle.dy * gameSpeed;
  rightPaddle.y += rightPaddle.dy * gameSpeed;

  // prevent paddles from going through walls
  if (leftPaddle.y < grid) {
    leftPaddle.y = grid;
  }
  else if (leftPaddle.y > maxPaddleY) {
    leftPaddle.y = maxPaddleY;
  }

  if (rightPaddle.y < grid) {
    rightPaddle.y = grid;
  }
  else if (rightPaddle.y > maxPaddleY) {
    rightPaddle.y = maxPaddleY;
  }

  // draw paddles
  drawPaddle(leftPaddle, true);
  drawPaddle(rightPaddle, false);
  
  // draw the court
  drawCourt();

  // move ball by its velocity
  ball.x += ball.dx * gameSpeed;
  ball.y += ball.dy * gameSpeed;

  // prevent ball from going through walls by changing its velocity
  if (ball.y < grid) {
    ball.y = grid;
    ball.dy *= -1;
    screenShake = 3;
  }
  else if (ball.y + ball.height > canvas.height - grid) {
    ball.y = canvas.height - grid - ball.height;
    ball.dy *= -1;
    screenShake = 3;
  }

  // Check if ball is close to edge for slow motion
  if (!ball.resetting && 
      ((ball.dx < 0 && ball.x < 100) || 
       (ball.dx > 0 && ball.x > canvas.width - 100))) {
    slowMotion = 30;
  }

  // reset ball if it goes past paddle (but only if we haven't already done so)
  if (ball.x < 0 && !ball.resetting) {
    rightScore++;
    ball.resetting = true;
    screenShake = 10;

    // give some time for the player to recover before launching the ball again
    setTimeout(() => {
      ball.resetting = false;
      ball.x = canvas.width / 2;
      ball.y = canvas.height / 2;
      // Alternate serve direction
      ball.dx = ballSpeed * (rightScore % 2 === 0 ? 1 : -1);
      ball.dy = (Math.random() * 2 - 1) * ballSpeed/2;
    }, 1000);
  } 
  else if (ball.x > canvas.width && !ball.resetting) {
    leftScore++;
    ball.resetting = true;
    screenShake = 10;

    setTimeout(() => {
      ball.resetting = false;
      ball.x = canvas.width / 2;
      ball.y = canvas.height / 2;
      // Alternate serve direction
      ball.dx = ballSpeed * (leftScore % 2 === 0 ? -1 : 1);
      ball.dy = (Math.random() * 2 - 1) * ballSpeed/2;
    }, 1000);
  }

  // check to see if ball collides with paddle. if they do change x velocity
  if (collides(ball, leftPaddle)) {
    ball.dx *= -1;

    // move ball next to the paddle otherwise the collision will happen again
    // in the next frame
    ball.x = leftPaddle.x + leftPaddle.width;
    
    // Slightly randomize the angle of the ball after paddle hit
    ball.dy = (Math.random() * 10 - 5) * 0.5;
    
    // Add particles and screen shake
    createHitParticles(ball.x, ball.y, 1);
    screenShake = 5;
    
    // Increase ball speed slightly with each hit
    ball.dx *= 1.05;
    if (Math.abs(ball.dx) > ballSpeed * 2) {
      ball.dx = (ball.dx > 0 ? 1 : -1) * ballSpeed * 2;
    }
  }
  else if (collides(ball, rightPaddle)) {
    ball.dx *= -1;

    // move ball next to the paddle otherwise the collision will happen again
    // in the next frame
    ball.x = rightPaddle.x - ball.width;
    
    // Slightly randomize the angle of the ball after paddle hit
    ball.dy = (Math.random() * 10 - 5) * 0.5;
    
    // Add particles and screen shake
    createHitParticles(ball.x, ball.y, -1);
    screenShake = 5;
    
    // Increase ball speed slightly with each hit
    ball.dx *= 1.05;
    if (Math.abs(ball.dx) > ballSpeed * 2) {
      ball.dx = (ball.dx > 0 ? 1 : -1) * ballSpeed * 2;
    }
  }

  // Update and draw particles
  particles = particles.filter(p => {
    const alive = p.update();
    if (alive) p.draw();
    return alive;
  });

  // draw ball
  drawBall();
  
  context.restore();
}

// start the game
requestAnimationFrame(loop);
</script>
</body>
</html>



